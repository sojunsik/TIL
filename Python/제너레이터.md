## 제너레이터

  # 1.제러레이터
    제너레이터는  이터레이터를 생성하는 객체입니다. 
    모든 제너레이터는 이터레이터에 속합니다. 
    값을 순차적으로 생성해 메모리 효율성을 높입니다.

   생성
    보통 컴프리헨션 문법과 yield 키워드를 통해 제너레이터를 생성합니다.
    ```code
     fow = (i for i in range(1,6)
     print(type(foo))
    ```
    컴프리헨션 문법을 통해 생성된 제너레이터를 제너레이터 표현식이라고 합니다. 
    [ ] 이 아닌 ( )  를 사용합니다.

   # yield 키워드
    ```code
     def func():
         for i in range(1,6):
             yield i 
     fow2 = func()
     print(type(fow2)) # <class 'generator'>
    ```
    함수 안에 yield 키워드를 사용하면 그 함수는 무조건 제너레이터가 됩니다.
    yield 키워드가 함수 내에서 전혀 사용되지 않는다 하더라도 제너레이터가 됩니다. 

    이렇게 생성된 fow, fow2 모두 next 메소드를 통해 값에 접근할 수 있습니다. 
    제너레이터도 이터레이터에 속하기 때문에 불러올 값이 더 이상 없으면 StopIteration 예외가 발생합니다.

   # yield 동작
   ![image](https://github.com/user-attachments/assets/61f03021-037f-429d-ac2e-57c1f95ba0ed)

    제너레이터 함수는 yield를 통해 값을 리턴합니다. 
    next나 for문을 통해 값들을 리턴받는데 yield가 호출된다고 해서 함수가 종료되는것이 아닙니다.
    yield가 호출되면 값을 반환하고 그 시점에서 함수를 잠시 정지 시킵니다. 
    그리고 다음 next가 호출되면 정지된 시점부터 다시 로직을 실행합니다.
    return과 다른점은 return은 호출되면 함수를 종료시키지만 yield는 호출되면 종료가 안됩니다.

    제너레이터 함수는 yield를 통해 값을 리턴합니다. 
    next나 for문을 통해 값들을 리턴받는데 yield가 호출된다고 해서 함수가 종료되는것이 아닙니다.
    yield가 호출되면 값을 반환하고 그 시점에서 함수를 잠시 정지 시킵니다. 
    그리고 다음 next가 호출되면 정지된 시점부터 다시 로직을 실행합니다.
    return과 다른점은 return은 호출되면 함수를 종료시키지만 yield는 호출되면 종료가 안됩니다.
    
    
