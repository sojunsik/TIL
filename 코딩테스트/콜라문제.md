## 콜라 문제
 #  문제 설명
     
  오래전 유행했던 콜라 문제가 있습니다. 콜라 문제의 지문은 다음과 같습니다.

  정답은 아무에게도 말하지 마세요.

  콜라 빈 병 2개를 가져다주면 콜라 1병을 주는 마트가 있다. 빈 병 20개를 가져다주면 몇 병을 받을 수 있는가?

  단, 보유 중인 빈 병이 2개 미만이면, 콜라를 받을 수 없다.

  문제를 풀던 상빈이는 콜라 문제의 완벽한 해답을 찾았습니다. 상빈이가 푼 방법은 아래 그림과 같습니다. 우선 콜라 빈 병 20병을 가져가서 10병을 받습니다. 
  받은 10병을 모두 마신 뒤, 가져가서 5병을 받습니다. 5병 중 4병을 모두 마신 뒤 가져가서 2병을 받고, 또 2병을 모두 마신 뒤 가져가서 1병을 받습니다. 
  받은 1병과 5병을 받았을 때 남은 1병을 모두 마신 뒤 가져가면 1병을 또 받을 수 있습니다. 이 경우 상빈이는 총 10 + 5 + 2 + 1 + 1 = 19병의 콜라를 받을 수 있습니다.

  ![image](https://github.com/user-attachments/assets/a93a2338-036c-42a4-82b5-ab0a3dadca49)
  
  문제를 열심히 풀던 상빈이는 일반화된 콜라 문제를 생각했습니다. 이 문제는 빈 병 a개를 가져다주면 콜라 b병을 주는 마트가 있을 때, 빈 병 n개를 가져다주면 몇 병을 받을 수 있는지 계산하는 문제입니다. 
  기존 콜라 문제와 마찬가지로, 보유 중인 빈 병이 a개 미만이면, 추가적으로 빈 병을 받을 순 없습니다. 상빈이는 열심히 고심했지만, 일반화된 콜라 문제의 답을 찾을 수 없었습니다. 
  상빈이를 도와, 일반화된 콜라 문제를 해결하는 프로그램을 만들어 주세요.

  콜라를 받기 위해 마트에 주어야 하는 병 수 a, 빈 병 a개를 가져다 주면 마트가 주는 콜라 병 수 b, 상빈이가 가지고 있는 빈 병의 개수 n이 매개변수로 주어집니다. 
  상빈이가 받을 수 있는 콜라의 병 수를 return 하도록 solution 함수를 작성해주세요.

  입출력 예제
  | a | b | n  | result |
  |---|---|----|--------|
  | 2 | 1 | 20 | 19     |
  | 3 | 1 | 20 | 9      |


  ## 풀이
   #  로직

      콜라를 마시고 전체값보다 작은 최대값만큼 교환
      남은 콜라를 저장하고 위의 과정을 콜라를 교환할
      수 없을때까지 진행
      
      빈병 a개를 가져가주면
      콜라 b병을 주는 마트가 있을 때
      빈병 n개를 가져다주면 몇 병을 받을 수 있는지
      
      
      가지고 있는 콜라의 개수를 저장하는 리스트 : cola
      받을 콜라의 개수 - take
      take를 0의로 초기화
      Cola를 n개로 초기화
      while(n>1):
      if(a*take가 n보다 작은 값중 최댓값)
         cola = cola - a*take + 받은 콜라
      위의 과정 반복

   # 첫번째 풀이
     def solution(a, b, n):
    cola = [] // cola 초기화
    
    total =0 //콜라를 더해줄 값 초기화
    while(n>1): 
        take = n//a n를 a로 몫 구하기
        n = n-a*take +take // 콜라의 개수 구하기
        cola.append(take) // 각각의 계산에서 구한 콜라의 개수 저장
    
    for i in range(0,len(cola)):
        total += cola[i] // 저장했던 콜라의 개수를 더하기
        
    return total // 콜라의 값 리턴

   # 피드백
     위의 과정으로 진행하고 실행을 하였습니다.
     실행결과 1번케이스는 통과하고 2번케이스는 시간초과로 통과하지못했습니다.
     위의 과정이 시간이 오래 걸렸던 이유는 이 코드가 시간이 오래 걸리는 이유는 while 루프에서 n이 감소하지 않는 상황이 발생할 가능성이 있기 때문입니다. 
     조건에 따라 n이 충분히 줄어들지 않으면 무한 루프에 가깝게 반복을 이어가면서 루프가 끝나지 않고 계속해서 실행될 수 있습니다.
     이 부분에서 take 값이 0이 되면 n = n - a * take + take가 n = n + 0과 동일해져 n의 값이 변하지 않으므로 루프가 종료되지 않을 수 있습니다.

   # 두번째 풀이
     def solution(a, b, n):
       cola = [] // 콜라의 개수 저장할 리스트 초기화
       
       total =0 // 콜라의 개수를 더하는 변수 초기화
       while(n>=a):
           take = (n//a)*b // 교환하게 될 콜라의 개수
           n = n%a +take
           cola.append(take)
       
       for i in range(0,len(cola)):
           total += cola[i]
           
       return total
 # 피드백
    위의 과정으로 했을때 바로 통과했습니다.
    while(n>=a): // 결국 n 이 a보다 작으면 더이상 종료될수 없기 때문에 굳이 n>1이라는 조건이 필요가 없었습니다.
    take = (n//a)*b // 위의 테스트케이스는 b=1이였기 때문에 첫번째 시도일때 통과되었던것입니다. b가 1이상이 되면 틀리기 때문에 *b를 통해 해결했습니다.
    (n-a*take) = n%a 같은 결과값을 얻게 됩니다. n%a가 더 적은 시간을 소요하기 때문에 교체하였습니다.

 # 느낀점
    이번 문제를 풀면서 개선할 점이 몇 가지 있음을 깨달았습니다. 먼저, 문제에서 주어진 b 값을 사용하지 않았다는 점에서 코드의 완성도가 부족하다는 생각이 들었습니다. 
    문제 조건에 주어진 모든 변수를 활용하는 것이 중요하다는 점을 다시 깨달았습니다.
 
    또한, n - a * take를 n % a로 표현할 수 있었음을 뒤늦게 알아, 코드의 간결성을 높이기 위해서는 작성한 로직을 다시 한 번 점검하는 과정이 필요하다는 교훈을 얻었습니다.
 
    마지막으로, n > 1 조건 대신 문제 조건을 보다 잘 반영한 n >= a를 사용하는 것이 훨씬 적합했습니다. 앞으로는 조건식을 작성할 때 문제의 맥락을 조금 더 깊이 있게 이해하고 고민하는 습관을 들여야겠습니다.


                                                                           

  

